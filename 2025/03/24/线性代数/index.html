<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>线性代数应该这么学 | 靖玄电</title><meta name="author" content="silence-breaker"><meta name="copyright" content="silence-breaker"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="..."><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "线性代数应该这么学",
  "url": "https://silence-breaker.github.io/2025/03/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/",
  "image": "https://img.sosoos.com/i/2025/01/22/207159.webp",
  "datePublished": "2025-03-24T03:34:57.000Z",
  "dateModified": "2025-03-24T09:18:52.507Z",
  "author": [
    {
      "@type": "Person",
      "name": "silence-breaker",
      "url": "https://silence-breaker.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://silence-breaker.github.io/2025/03/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线性代数应该这么学',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://img.sosoos.com/i/2025/01/22/426580.webp);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/loading.gif" data-original="https://img.sosoos.com/i/2025/01/22/207159.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">靖玄电</span></a><a class="nav-page-title" href="/"><span class="site-name">线性代数应该这么学</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">线性代数应该这么学</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-24T03:34:57.000Z" title="发表于 2025-03-24 11:34:57">2025-03-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-24T09:18:52.507Z" title="更新于 2025-03-24 17:18:52">2025-03-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">线性代数</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><em>谨以此篇献给学无止境的自己-----------silence-breaker</em></p>
<h1 id="初步认识矩阵">初步认识矩阵</h1>
<h2 id="从线性方程组入手">从线性方程组入手</h2>
<p>生活中我们常常需要通过求方程组的解来解决一些数学问题，对于一些比较特殊的方程组，如线性方程组：
<span class="math display">\[
\begin{aligned}
0x_{1}-1y_{1}=x_{2}\\
-2x_{1}+0y_{1}=y_{2}  \\
\end{aligned}
\]</span> 我们可以把它们写成一种简约的形式： <span class="math display">\[
\begin{pmatrix}
0&amp;-1 \\
-2&amp;0 \\
\end{pmatrix}
\begin{pmatrix}
x_{1} \\
y_{1} \\
\end{pmatrix}
=\begin{pmatrix}
x_{2} \\
y_{2} \\
\end{pmatrix}
\]</span> 这是从线性方程组入手写出来的矩阵方程</p>
<h2 id="从向量方程入手">从向量方程入手</h2>
<h3 id="如何理解一个矩阵">如何理解一个矩阵</h3>
<p>首先我们来熟悉一些概念，我们怎么表达向量，向量之间是如何进行转换计算的，向量之间的关系是什么，什么是向量空间......
初高中我们就已经开始接触向量，不过那时候我们通常用的是 <span class="math inline">\((1,2)\)</span>
这类形式去标识一个向量，那么现在我们换一种更加清晰地表达方式 <span class="math display">\[
(1,2)\to \begin{pmatrix}
1 \\
2
\end{pmatrix}
\]</span>
可以看到右边括号中，一行代表一个维度，一列代表一个向量（至于为什么这么写，是为了之后方便理解和计算），像这样只有一列的向量我们称之为<strong>列向量</strong>
那么如何表达一个空间中的一组基呢？显然，我们把不同的列向量拼在一起 <span class="math display">\[
\begin{pmatrix}
1&amp;0 \\
0&amp;1
\end{pmatrix}
\]</span> 这个就是二维空间中最经典的标准基，我们定义左边的为向量 <span class="math inline">\(\vec{i}\)</span>， 右边的为向量 <span class="math inline">\(\vec{j}\)</span>，我们可以对这组基进行伸缩、旋转
<span class="math display">\[
\begin{pmatrix}
1&amp;0 \\
0&amp;1
\end{pmatrix}\to \begin{pmatrix}
0&amp;-1 \\
2&amp;0
\end{pmatrix}
\]</span> 这个变换过程就是将这组基逆时针旋转
90°，然后第一个向量拉长为原来的两倍。更进一步的，可以把这个过程想象成直角坐标系（空间被划分为无数个等大的小方格）连带着向量伸缩，旋转的过程。值得注意的是，在这种变换过程中，无论我们怎么伸缩、旋转，我们的原点始终不会变，空间仍然被分为很多个相同的小方格（保持网格线平行且等距分布），这种变换我们称之为<strong>线性变换</strong>（几何层面感性的理解）
<img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cc4c2578.png" alt="线性变换.png">
更广义地去说<strong>线性变换</strong>，我们常常定义 <span class="math inline">\(T(\vec{x})\)</span>，称 <span class="math inline">\(T\)</span> 为对向量 <span class="math inline">\(\vec{x}\)</span> 的线性变换，它满足以下公理：
<span class="math display">\[
\begin{aligned}
T(\vec{x}+\vec{y})=T(\vec{x})+T(\vec{y})
\\T(\vec{c}x)=cT(\vec{x})
\end{aligned}
\]</span> 通常我们通过对一个向量做线性变换，然后得到另一个向量，即：
<span class="math display">\[
T(\vec{x})=\vec{b}
\]</span> 这是一个很抽象的表达式，继续拿刚刚旋转 90°，<span class="math inline">\(\vec{i}\)</span>
拉长为原来两倍的例子来说，我们如何去表达一个在原来坐标系下的 <span class="math inline">\(\vec{b}\)</span> 经过线性变换后的产生的 <span class="math inline">\(\vec{d}\)</span> 呢？我们很容易想到，<span class="math inline">\(\vec{b}\)</span> 是跟随着 <span class="math inline">\(\vec{i}，\vec{j}\)</span>
同步变化的，也就是对它俩做什么操作，就对 <span class="math inline">\(\vec{b}\)</span> 做什么操作
（一维对应一维的变化），因此我们可以写成 <span class="math display">\[
\begin{pmatrix}
0&amp;-1 \\
2&amp;0
\end{pmatrix}\begin{pmatrix}
x_{1} \\
y_{1}
\end{pmatrix}=\begin{pmatrix}
x_{2} \\
y_{2}
\end{pmatrix}
\to \begin{pmatrix}
0 \\
2
\end{pmatrix}x_{1}+\begin{pmatrix}
-1 \\
0
\end{pmatrix}y_{1}=\begin{pmatrix}
x_{2} \\
y_{2}
\end{pmatrix}
\]</span>
这样，是不是就可以和最开始的线性方程组联系起来了？因此矩阵（向量）方程最终都可以转化为线性方程组的形式
我们再进一步对矩阵进行理解，形如 <span class="math display">\[
\begin{pmatrix}
1&amp;2&amp;3 \\
4&amp;5&amp;6
\end{pmatrix}
\]</span>
可以看作三维向量向二维空间的转换（列数是原来空间的向量的个数，写出来的数字是每一个向量变换后的结果）
<span class="math display">\[
\begin{pmatrix}
a&amp;0&amp;0 \\
0&amp;a&amp;0 \\
0&amp;0&amp;a
\end{pmatrix}
\]</span> 可以看作三维每个坐标轴伸长为原来的 a 倍，如果 a 为 1
那么就相当于对原来的坐标系不做任何变换，这种矩阵叫做<strong>单位阵</strong>
### 一般性矩阵乘法 那么对于一般的矩阵方程我们应该如何运算呢？
从上面的例子中我们得知，代表线性变换的矩阵的列数（左侧）必须与进行变换的矩阵行数（右侧）相等，本质上来说就是进行变换的维度一一对应
(<span class="math inline">\(R^{m*n}*R^{n*q}=R^{m*q}\)</span>) <span class="math display">\[
\begin{pmatrix}
a_{11}&amp;a_{12}&amp;\dots a_{1n} \\
. \\
. \\
a_{m1}&amp;a_{m2}&amp;\dots a_{mn}
\end{pmatrix}\begin{pmatrix}
b_{11}&amp;b_{12}&amp;\dots b_{1q} \\
. \\
. \\
b_{n1}&amp;a_{n2}&amp;\dots a_{nq}
\end{pmatrix}
\]</span>
这似乎一下子看会有点懵，若以<strong>矩阵分块</strong>思想，可以很好的和刚刚的例子联系起来
<strong>矩阵分块</strong>形象地来说就是把矩阵当作蛋糕一样横着切竖着切，形成一个个子矩阵
<span class="math display">\[
\begin{aligned}
\begin{pmatrix}
a_{11}&amp;a_{12}&amp;\dots a_{1n} \\
. \\
. \\
a_{m1}&amp;a_{m2}&amp;\dots a_{mn}
\end{pmatrix}\begin{pmatrix}
b_{1} \\
b_{2} \\
. \\
bn
\end{pmatrix}
\\=\begin{pmatrix}
a_{11} \\
. \\
. \\
a_{m1}
\end{pmatrix}b_{1}+\dots+\begin{pmatrix}
a_{1n} \\
. \\
. \\
a_{mn}
\end{pmatrix}b_{n}
\\=\begin{pmatrix}
a_{11}b_{1}+\dots a_{1n}b_{n} \\
. \\
. \\
a_{m1}b_{1}+\dots a_{mn}b_{n}
\end{pmatrix}
\\=\begin{pmatrix}
\sum_{k=1}^{n}a_{1k}b_{k_q}&amp; \dots \sum_{k=1}^{n}a_{1k}b_{kq} \\
. \\
. \\
\sum_{k=1}^{n}a_{mk}b_{k1}&amp; \dots \sum_{k=1}^{n}a_{mk}b_{kq}
\end{pmatrix}
\end{aligned}
\]</span> 所以我们可以得到矩阵解的 <span class="math inline">\(c_{ij}=\sum_{k=1}^{n}a_{ik}b_{kj}\)</span>（第 i
行第 j 列）
从线性变换的角度我们可以很容易理解矩阵乘法具有方向性，并不能随意互换，先伸缩再旋转和先旋转再伸缩得到的结果不一定一样，即
<span class="math display">\[
AB\neq BA
\]</span></p>
<h3 id="初等行变换">初等行变换</h3>
<p>矩阵的初等操作包括 interchange（行交换）, scaling（行倍增）,
replacement（<span class="math inline">\(cr_{i}+r_{j}\to
r_{j}\)</span>）
这里不提列操作是因为转置后对行操作就是相当于对原来矩阵进行列操作</p>
<h3 id="行列式">行列式</h3>
<p>大多数人在学习线性代数的时候都知道如何计算行列式，但对于它本身的意义却并不清晰
其实从几何的角度理解，<strong>行列式代表了变换后面积与变换前面积的比例</strong>（这个理解对于后续行列式相关性质的理解至关重要）
首先我们从二维空间开始 <span class="math display">\[
\begin{aligned}
A=\begin{pmatrix}
1&amp;0 \\
0&amp;1
\end{pmatrix}\to B=\begin{pmatrix}
2&amp;0 \\
0&amp;2
\end{pmatrix}
\\[0.5cm]
|A|=1,|B|=4
\end{aligned}
\]</span> A 的行列式看作两个向量所围成的 1* 1 方块面积，B 的行列式看作
2* 2 方块面积，相当于由 A 变成 B，向量所围面积是原来的 4 倍
接下来做更一般性推广 <span class="math display">\[
\begin{aligned}
A&#39;=\begin{pmatrix}
a&amp;b \\
c&amp;d
\end{pmatrix}
\\[0.5cm]
|A|=ad-bc
\end{aligned}
\]</span> 按我们的猜想，从 A 变换成 A‘，面积扩大为原来的 <span class="math inline">\(ad-bc\)</span> 倍，下面是严格的证明： - a 和 d
分别为原来两个基向量方向扩大的倍数，所以如果 b c 为 0，那么 a d
显然就是面积扩大的倍数 - 若 c 不等于零，b 等于 0，也就是说，x
方向向量不仅延长为原来 a 倍后还向上移动了 c
个单位，这相当于把第一种情况扩大的矩形搓成了一个平行四边形，面积不变 -
若 a b c d 都不等于 0，如果说 a d 表示在水平竖直方向上的拉伸压缩，那么 b
c
体现的就是平行四边形在对角方向上的拉伸压缩（这应该很容易想象）下图是严格的推导
<img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cc558fa9.png" alt="行列式面积理解.png">
那么行列式是负数的情况怎么理解呢，这可以看成两个向量本来是右手系，但是线性变换后变成了左手系，表示另一边的面积，所以取负号，可以区分
通过建立行列式的几何印象理解后，我们很容易理解为什么只有 n* n
阶行列式，而且我们不难发现可以对行列式性质一眼盯真： <span class="math display">\[
\begin{aligned}
\begin{vmatrix}
n*col_{1}&amp;m*col_{2}&amp;\dots&amp;col_{n}
\end{vmatrix}=nm\begin{vmatrix}
col_{1}&amp;col_{2}&amp;\dots&amp;col_{n}
\end{vmatrix}
\\\begin{vmatrix}
col_{1}&amp;col_{2}&amp;\dots&amp;col_{n}
\end{vmatrix}=-\begin{vmatrix}
col_{2}&amp;col_{1}&amp;\dots&amp;col_{n}
\end{vmatrix}\\
\begin{vmatrix}
col_{1}&amp;c*col_{1}+col_{2}&amp;col_{3}\dots col_{n}
\end{vmatrix}=\begin{vmatrix}
col_{1}&amp;col_{2}&amp;col_{3} \dots col_{n}
\end{vmatrix}
\\\begin{vmatrix}
AB
\end{vmatrix}=\begin{vmatrix}
A
\end{vmatrix}\begin{vmatrix}
B
\end{vmatrix}
\end{aligned}
\]</span>
（对第二条做进一步解释）列互换相当于从右手系变成左手系，行列式<em>（-1），再互换一次，相当于从左手系变成右手系，行列式</em>（-1）
（对第三条做进一步解释）<span class="math inline">\(col_{2}\)</span>
加上 <span class="math inline">\(n*col_{1}\)</span>
后，向量的端点始终在原来所处的那条栅格线上移动，面积并没有改变（类似于平行四边形推拉）
（对第四条做进一步解释）由于没有改变矩阵相乘的顺序，所以结果当然一致，最终形成的体积大小都一致
由前三条性质可以进一步推导出<strong>第四条性质</strong>： <span class="math display">\[
\begin{aligned}
\begin{vmatrix}
col_{1}&amp;col_{2}+col&#39;&amp;\dots&amp;col_{n}
\end{vmatrix}=\begin{vmatrix}
col_{1}&amp;col_{2}&amp;\dots&amp;col_{n}
\end{vmatrix}+\begin{vmatrix}
col_{1}&amp;col&#39;&amp;\dots&amp;col_{n}
\end{vmatrix}
\end{aligned}
\]</span>
或许有人对行列式的行操作存在疑惑（因为上面都以列操作为例），你只需要设定一组新的规则，每行表示一个向量，每列表示一个维度即可
<strong>关于主对角线和副对角线行列式计算结论</strong>： -
易得如果元素全部位于主对角线，就相当于在右手系下每一个维度乘上一个常数，副对角线可以通过行变换成主对角线去计算。
- 如果行列式成主倒三角型（即 echelon
阶梯型）（元素都在主对角线及之上），这也很好理解：先写上主对角线的数字，从最左边依次做
replacement
填充主对角线上面的数字，这时候做变换并不影响行列式的大小，所以 echelon
阶梯型行列式的大小就是主对角线上数字的乘积 ###
高阶行列式（如何理解余子式） 对于二阶以上的行列式我们采用以下公式计算
首先引入<strong>代数余子式</strong>概念：<span class="math inline">\(A_{ij}=(-1)^{i+j}|\overline{A_{ij}|}\)</span>
计算行列式时按行或者按列展开，化为更小阶的行列式，有没有想过为什么这么计算呢？
我们来逐步理解<strong>余子式的含义</strong>，我们拿一个具体的例子来说：
<span class="math display">\[
A=\begin{pmatrix}
1&amp;2&amp;3 \\
4&amp;5&amp;6 \\
7&amp;8&amp;9
\end{pmatrix}
\]</span> <span class="math inline">\(|A|\)</span>
表示三个列向量在三维空间中围成六面体的体积，我们现在看余子式（按第一行展开）：
<span class="math display">\[
\begin{vmatrix}
5&amp;6 \\
8&amp;9
\end{vmatrix}\,\begin{vmatrix}
4&amp;6 \\
7&amp;9
\end{vmatrix}\,\begin{vmatrix}
4&amp;5 \\
7&amp;8
\end{vmatrix}
\]</span> 我们思考一下得到余子式的过程，我们去掉第一行，相当于把 x
轴砍掉，变成了 y, z 轴围成的二维平面，而<strong>余子式表示的就是 <span class="math inline">\(yoz\)</span> 平面上向量围成的矢量面积</strong>
而求 <span class="math inline">\(|A|\)</span> 就相当于 x 轴上的高乘上
<span class="math inline">\(yoz\)</span>
平面围成的面积得到的体积总和，而列向量在 x
轴上的分量增大不一定意味着总体积就增大（想象一下靠近压缩的过程），所以我们采用逆序数规定谁的分量增大带来的是正向结果，谁的分量增大带来的是负向结果
# 求解方程 ## 矩阵的逆
在上一章我们探讨了矩阵对应的线性变换，了解了正向的矩阵乘法。在实际应用中，我们通常用于求解方程的解，这是一个逆向的过程
<span class="math display">\[
\begin{aligned}
A\vec{x}=\vec{b}\\
\vec{x}=A^{-1}\vec{b}
\end{aligned}
\]</span>
因此，求出矩阵的逆成为求解方程组的关键。从几何的角度理解，就是将线性变换的操作反过来进行
可以推知，矩阵的逆具有以下性质 <span class="math display">\[
A^{-1}A=AA^{-1}=I(单位阵)
\]</span> 如何求出矩阵的逆？ <strong>法 1：</strong>（E
表示对矩阵做的行操作） <span class="math display">\[
\begin{aligned}  
A\to E_{1}A\to E_{2}E_{1}A\to\dots\to E_{n}E_{n-1}\dots E_{1}A=I\to
E_{n}E_{n-1}\dots E_{1}=A^{-1}\\
\begin{pmatrix}
A&amp;I
\end{pmatrix}\to \begin{pmatrix}
E_{n}E_{n-1}\dots E_{1}A&amp;E_{n}E_{n-1}\dots E_{1}I
\end{pmatrix}\to \begin{pmatrix}
I&amp;A^{-1}
\end{pmatrix}
\end{aligned}
\]</span> <strong>法 2：</strong> <span class="math display">\[
A^{-1}=\frac{A^{*}}{|A|}
\]</span></p>
<p><strong>伴随矩阵定义</strong> <span class="math display">\[
A^*=\begin{pmatrix}
A_{11}&amp;A_{21}&amp;\dots&amp;A_{n_{1}} \\
. \\
. \\
A_{1n}&amp;A_{2n}&amp;\dots&amp;A_{nn}
\end{pmatrix}
\]</span> 证明逆矩阵的式子相当于证明： <span class="math display">\[
AA^*=|A|I
\]</span>
（鉴于同济版的书上有证明过程所以这里不再赘述）可以发现结果矩阵中只有对角线上的元素不为零且大小为
<span class="math inline">\(|A|\)</span> ### 矩阵逆的存在性
并不是所有矩阵都存在逆矩阵，当行列式为 0
时逆矩阵不存在，那么如何理解这个点呢？ 根据上文，行列式为 0
时意味着矩阵变换降维，例如三维的体积压缩成了一个面，二维的面积压缩成了一个点。如：
<span class="math display">\[
\begin{aligned}
\begin{pmatrix}
1&amp;1 \\
0&amp;0
\end{pmatrix}
\end{aligned}
\]</span>
如果你要还原成原来的标准基形式，你需要把一条线拓展成一个面，无论你怎么旋转，伸长，压缩，始终还是一条线，所以行列式为
0 的时候逆矩阵不存在 ## 克莱姆法则 对于一般的线性方程组： <span class="math display">\[
\begin{aligned}
3x_{1}+4x_{2}+5x_{3}=7\\
x_{1}+9x_{2}+7x_{3}=8\\
5x_{1}+7x_{2}+10x_{3}=5
\end{aligned}
\]</span> 我们写成矩阵形式进行求解 <span class="math display">\[
\begin{pmatrix}
3&amp;4&amp;5 \\
1&amp;9&amp;7 \\
5&amp;7&amp;10
\end{pmatrix}\begin{pmatrix}
x_{1} \\
x_{2} \\
x_{3}
\end{pmatrix}=\begin{pmatrix}
7 \\
8 \\
5
\end{pmatrix}=\vec{b}
\]</span>
按照克莱姆法则我们不需要求矩阵的逆，仅通过计算行列式可以得出每一个解
<span class="math display">\[
\begin{aligned}
x_{1}=\frac{\begin{vmatrix}
\vec{b}&amp;col_{2}&amp;col_{3}
\end{vmatrix}}{\begin{vmatrix}
col_{1}&amp;col_{2}&amp;col_{3}
\end{vmatrix}}
\end{aligned}
\]</span> 其余解以此类推，用 <span class="math inline">\(\vec{b}\)</span> 代替对应那一列，然后求行列式
<strong>但是，为什么这么做就可以求出解呢？</strong>
为了更形象，这里我们写成（第一个矩阵标记为 A，结果矩阵标记为 B） <span class="math display">\[
\begin{aligned}  
\begin{pmatrix}
u_{1}&amp;v_{1}&amp;w_{1} \\
u_{2}&amp;v_{2}&amp;w_{2} \\
u_{3}&amp;v_{3}&amp;w_{3}
\end{pmatrix}\begin{pmatrix}
x \\
y \\
z
\end{pmatrix}=\begin{pmatrix}
b_{1} \\
b_{2} \\
b_{3}
\end{pmatrix}
\end{aligned}
\]</span> 我们可以从体积（行列式）的角度表示 <span class="math inline">\(x,y,z\)</span> <span class="math display">\[
\begin{aligned}
x=\begin{vmatrix}
x&amp;0&amp;0 \\
y&amp;1&amp;0 \\
z&amp;0&amp;1
\end{vmatrix}
\\
y=\begin{vmatrix}
1&amp;x&amp;0 \\
0&amp;y&amp;0 \\
0&amp;z&amp;1
\end{vmatrix}
\\
z=\begin{vmatrix}
1&amp;0&amp;x \\
0&amp;1&amp;y \\
0&amp;0&amp;z
\end{vmatrix}
\end{aligned}
\]</span> 这里很容易想象，体积的大小就是对应某一轴的坐标值 <img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cbe30a3f.png" alt="克莱默法则.png"> 以求 x 为例： 经过线性变换后 <span class="math display">\[
\begin{aligned}
\begin{pmatrix}
x \\
y \\
z
\end{pmatrix}\to \begin{pmatrix}
b_{1} \\
b_{2} \\
b_{3} \\
\end{pmatrix}
\\
\begin{pmatrix}
0 \\
1 \\
0
\end{pmatrix}\to \begin{pmatrix}
v_{1} \\
v_{2} \\
v_{3}
\end{pmatrix}\\
\begin{pmatrix}
0 \\
0 \\
1
\end{pmatrix}\to \begin{pmatrix}
w_{1} \\
w_{2} \\
w_{3}
\end{pmatrix}
\end{aligned}
\]</span> 所以变换后的体积为 <span class="math display">\[
\begin{vmatrix}
x&amp;0&amp;0 \\
y&amp;1&amp;0 \\
z&amp;0&amp;1
\end{vmatrix}\to
\begin{vmatrix}
b_{1}&amp;v_{1}&amp;w_{1} \\
b_{2}&amp;v_{2}&amp;w_{2} \\
b_{3}&amp;v_{3}&amp;w_{3}
\end{vmatrix}
\]</span> 如果我们知道这两个体积之间的比例是不是就可以把 x 算出来了？
这两个体积之间的比例就是做线性变换操作矩阵的行列式，即： <span class="math display">\[
\begin{vmatrix}
u_{1}&amp;v_{1}&amp;w_{1} \\
u_{2}&amp;v_{2}&amp;w_{2} \\
u_{3}&amp;v_{3}&amp;w_{3}
\end{vmatrix}\begin{vmatrix}
x&amp;0&amp;0 \\
y&amp;1&amp;0 \\
z&amp;0&amp;1
\end{vmatrix}=\begin{vmatrix}
b_{1}&amp;v_{1}&amp;w_{1} \\
b_{2}&amp;v_{2}&amp;w_{2} \\
b_{3}&amp;v_{3}&amp;w_{3}
\end{vmatrix}
\]</span> 所以我们得到 <span class="math display">\[
x=\frac{\begin{vmatrix}
b_{1}&amp;v_{1}&amp;w_{1} \\
b_{2}&amp;v_{2}&amp;w_{2} \\
b_{3}&amp;v_{3}&amp;w_{3}
\end{vmatrix}}{\begin{vmatrix}
u_{1}&amp;v_{1}&amp;w_{1} \\
u_{2}&amp;v_{2}&amp;w_{2} \\
u_{3}&amp;v_{3}&amp;w_{3}
\end{vmatrix}}
\]</span> 这，就是克莱姆法则的几何理解 ## 高斯消元法
我们在求解方程的时候可以把线性变换矩阵通过多次初等行变换变成<strong>主对角线阶梯型（echelon
form）</strong>，这样方便计算。这种算法就叫做高斯消元法。值得注意的是，进行初等行变换的时候遵循<strong>从左到右，从上到下</strong>的基本原则，把每行第一个不为
0 的数称作 <strong>leading entry（先导元素）</strong>，leading entry
所在的列叫做 <strong>pivot column（主元列）</strong> <span class="math display">\[
\begin{aligned}  
\begin{pmatrix}
u_{1}&amp;v_{1}&amp;w_{1} \\
0&amp;v_{2}&amp;w_{2} \\
0&amp;0&amp;w_{3}
\end{pmatrix}\begin{pmatrix}
x \\
y \\
z
\end{pmatrix}=\begin{pmatrix}
b_{1} \\
b_{2} \\
b_{3}
\end{pmatrix}
\end{aligned}
\]</span> 更进一步，我们可以再通过行变换化简成 <strong>reduced echelon
form（最简阶梯型）</strong>，此时只有主对角线上有元素，其他都是
0，更便于我们得出解 ### 通解和特解
当进行初等行变换之后出现并非所有列都是主元列，即以下状况： <span class="math display">\[
\begin{aligned}  
\begin{pmatrix}
u_{1}&amp;v_{1}&amp;w_{1} \\
0&amp;0&amp;w_{2} \\
0&amp;0&amp;w_{3}
\end{pmatrix}\begin{pmatrix}
x \\
y \\
z
\end{pmatrix}=\begin{pmatrix}
b_{1} \\
b_{2} \\
b_{3}
\end{pmatrix}
\end{aligned}
\]</span>
非主元列我们称之为<strong>自由变量</strong>，出现自由变量的时候我们会发现方程不止存在唯一的
solution 你会发现只有 <span class="math inline">\(z\)</span>
的大小是确定的，而 <span class="math inline">\(x\)</span> 的大小由 <span class="math inline">\(y\)</span> 来决定，我们可以把解写成如下形式：
<span class="math display">\[
\begin{pmatrix}
x \\
y \\
z
\end{pmatrix}=\begin{pmatrix}
b_{1}-\frac{w_{1}b_{1}}{w_{3}}-v_{1}y \\
y \\
\frac{b_{3}}{w_{3}}
\end{pmatrix}=\begin{pmatrix}
b_{1}-\frac{w_{1}b_{1}}{w_{3}} \\
0 \\
\frac{b_{3}}{w_{3}}
\end{pmatrix}+y\begin{pmatrix}
-v_{1} \\
1 \\
0
\end{pmatrix}
\]</span>
左边那个叫做<strong>特解</strong>，右边那个是方程的<strong>通解</strong>
注意，加入 <span class="math inline">\(\vec{b}=0\)</span>，右边那个仍然满足方程，这就是下文会提到的<strong>零空间的基</strong>
# 线性空间 ## 向量空间
我们通常称满足八大公理的向量集合为向量空间，八大定理如下： <span class="math display">\[
\begin{aligned}
\exists \vec{u},\vec{v},\vec{z},-\vec{z}\in V\\
\vec{u}+\vec{v}=\vec{v}+\vec{u}
\\
\vec{u}+(\vec{v}+\vec{z})=(\vec{u}+\vec{v})+\vec{z}
\\
-\vec{z}+\vec{z}=0\\
c(\vec{z}+\vec{u})=\vec{c}z+\vec{c}u\\
c(\vec{d}z)=c\vec{d}z\\
(c+d)\vec{z}=\vec{c}z+\vec{d}z\\
\vec{0}+\vec{z}=\vec{z}\\
1*\vec{z}=\vec{z}
\end{aligned}
\]</span> 不要小看这些公理，它们是线性代数分析的基石
向量空间中的向量子集如果仍然满足这八大定理，则称这些子集为<strong>子空间(subspace)</strong>，否则只能成为<strong>子集</strong>
- 我们称 <span class="math inline">\(span\{a_{1},a_{2},\dots,a_{n}\}\)</span> 为
<strong><span class="math inline">\(a_{1},a_{2},\dots,a_{n}\)</span>
张成的空间</strong>（但不一定是向量空间） 如果 <span class="math inline">\(\sum_{i=1}^{n}c_{i}a_{i}=0\)</span> 当且仅当所有
<span class="math inline">\(c_{i}=0\)</span>
时才成立，那么称这个空间里所有的向量<strong>线性独立</strong>
（其实这非常好理解，就是空间中任何一个向量都不可能用其他向量表示出来，维度都互不完全一致）
如果这些向量又恰好满足向量空间八大定理，那么我们称这些向量为它们张成的向量空间的<strong>基向量</strong>
## 列空间（Column space） 对于以下方程 <span class="math inline">\(\vec{b}\neq 0\)</span>
的解所构成的向量空间我们称为<strong>列空间</strong>，从另一个角度来说，A
中所有主元列（非主元也可算进去，毕竟维度有重复）向量张成的空间就是列空间（从上文几何角度理解线性变换可以很容易看出来），列空间基的个数=主元列的个数
<span class="math display">\[
A\vec{x}=\vec{b}\to \begin{pmatrix}
col_{1}&amp;col_{2}&amp;\dots&amp;col_{n}
\end{pmatrix}\begin{pmatrix}
x_{1} \\
x_{2} \\
. \\
x_{n}
\end{pmatrix}=\vec{b}
\]</span> ## 行空间（Row space） A
中所有行向量所组成的空间我们称为行空间，<strong>行空间基的个数=列空间基的个数</strong>
如何理解呢？ 和列空间分析类似，在化简成 echelon
form（阶梯型）之后我们可以发现 pivot column 的个数和 pivot row
的个数其实一致（因为 leading entry 的个数是固定的，而且都是成阶梯型）
<span class="math display">\[
\begin{aligned}  
\begin{pmatrix}
u_{1}&amp;v_{1}&amp;w_{1} \\
0&amp;0&amp;w_{2} \\
0&amp;0&amp;w_{3}
\end{pmatrix}\begin{pmatrix}
x \\
y \\
z
\end{pmatrix}=\begin{pmatrix}
b_{1} \\
b_{2} \\
b_{3}
\end{pmatrix}
\end{aligned}
\]</span></p>
<h2 id="零空间null-space">零空间（Null space）</h2>
<p>对于以下方程 <span class="math inline">\(\vec{b}=0\)</span>
的通解所构成的向量空间我们称为<strong>零空间</strong>，可以看回<strong>高斯消元法</strong>中
<span class="math inline">\(\vec{b}=0\)</span>
的那个例子，我们可以归纳出<strong>零空间基的个数=自由变量的个数</strong></p>
<p>从<strong>几何意义</strong>上来理解，经过线性变换后，空间坍缩成 <span class="math display">\[
\begin{pmatrix}
u_{1} \\
0 \\
0
\end{pmatrix}+\begin{pmatrix}
w_{1} \\
w_{2} \\
w_{3}
\end{pmatrix}
\]</span> 这两个向量（把第一个换成第二个列向量 <span class="math inline">\((v1,0,0)\)</span>
也一样）所组成的平面，我们的解只能在这个平面上移动 ## 秩 我们通常用
<span class="math inline">\(rank(A)\)</span> 来表示一个矩阵的秩，<span class="math inline">\(dim(V)\)</span> 表示一个向量空间的维度 <span class="math display">\[
rank(A)=dim(Col_{A})+dim(Nul_{A})
\]</span>
因为一个矩阵中的列向量不是主元列就是自由变量，所以我们可以得到<strong>列空间基的个数+零空间基的个数=矩阵的列数（n）</strong>
或者可以称之为矩阵的维度，因为一般我们都是分析<strong>方阵</strong> -
如果我们说一个矩阵<strong>满秩</strong>，那么代表 <span class="math inline">\(rank(A)=dim(Col_{A})\)</span>，也就是说矩阵所有列都是主元列，变换后的空间没有坍缩，那么这个矩阵<strong>可逆</strong>（这里判断通常要通过行变化化简成阶梯型才方便判断，不可以不做任何处理）
## 基变换
我们现在知道一个向量空间可以用一组基表示，那么向量空间只能有一组基吗？显然不是，我们可以用不同的“基语言”去描述空间中的变化
比如对于二维空间，我们可以用这组标准的向量基（类比普通话）来描述 <span class="math display">\[
\begin{pmatrix}
1&amp;0 \\
0&amp;1
\end{pmatrix}
\]</span> 但是我们也可以用方言（类比粤语）来描述 <span class="math display">\[
\begin{pmatrix}
3&amp;1 \\
2&amp;5
\end{pmatrix}
\]</span></p>
<p>如果我们用普通话描述了一种线性变换 <span class="math inline">\(D\)</span> ，那么如何用粤语来描述这种线性变换呢？
显然我们可以得到以下思路：<strong>先把粤语翻译成普通话，用普通话完成这个线性变换，然后再翻译回粤语，那么就相当于用粤语来描述这种线性变换了</strong>
<strong>值得注意的是</strong>，在粤语世界里，我们所说的 <span class="math inline">\(\begin{pmatrix}1&amp;0\\0&amp;1\end{pmatrix}\)</span>
其实对应的是普通话中的 <span class="math inline">\(\begin{pmatrix}3&amp;1
\\2&amp;5\end{pmatrix}\)</span>
，所以当我们在写出粤语基的时候，我们已经把粤语翻译成普通话了
所以要实现用粤语来描述 D，那么就是 <span class="math display">\[
粤语^{-1}D粤语\to \begin{pmatrix}
3&amp;1 \\
2&amp;5
\end{pmatrix}^{-1}D\begin{pmatrix}
3&amp;1 \\
2&amp;5
\end{pmatrix}
\]</span> 如果这个 D
还是一个对角矩阵的话，这就涉及到了之后会提到的<strong>对角化问题</strong>，我们可以从基变换的角度大大减少计算量</p>
<p>那么对于普通的基变换问题（A 语言转成 B
语言），我们通常探究的是如何用不同语言表达同一个列向量，假设我们有 <span class="math inline">\(A,B\)</span> 这两组基 <span class="math display">\[
\begin{aligned}  
A=\{\vec{a_{1}},\vec{a_{2}}\dots\vec{a_{n}}\}\\
B=\{\vec{b_{1}},\vec{b_{2}}\dots\vec{b_{n}}\}
\end{aligned}
\]</span> 我们在 <span class="math inline">\(A\)</span> 下描述 <span class="math inline">\(\vec{x}\)</span> <span class="math display">\[
\begin{aligned}  
\vec{x_{A}}=\begin{pmatrix}
c_{1} \\
c_{2} \\
. \\
. \\
c_{n}
\end{pmatrix}\\
\vec{x_{A}}=c_{1}\vec{a_{1}}+\dots+c_{n}\vec{a_{n}}
\end{aligned}
\]</span> 那么如何在 B 下描述 <span class="math inline">\(\vec{x}\)</span> 呢？ <span class="math display">\[
\begin{aligned}
(\vec{x_{A}})*{B}=(c*{1}\vec{a_{1}}+\dots+c_{n}\vec{a_{n}})*{B}=c*{1}(\vec{a_{1}})*{B}+\dots+c*{n}(\vec{a_{n}})*{B}=A*{B}\begin{pmatrix}
c_{1} \\
c_{2} \\
. \\
. \\
c_{n}
\end{pmatrix}\\
\vec{x_{B}}=\begin{pmatrix}
d_{1} \\
d_{2} \\
. \\
. \\
d_{n}
\end{pmatrix}\\
\end{aligned}
\]</span> <span class="math inline">\(\vec{x_{A}}\)</span> 和 <span class="math inline">\(\vec{x_{B}}\)</span> 关系如下： <span class="math display">\[
\begin{aligned}  
A_{B}=\begin{pmatrix}
\vec{a_{1}}*{B}&amp;\vec{a*{2}}*{B}&amp;\dots&amp;\vec{a*{n}}*{B}
\end{pmatrix}\\
\begin{pmatrix}
d*{1} \\
d_{2} \\
. \\
. \\
d_{n}
\end{pmatrix}=\begin{pmatrix}
\vec{a_{1}}*{B}&amp;\vec{a*{2}}*{B}&amp;\dots&amp;\vec{a*{n}}*{B}
\end{pmatrix}\begin{pmatrix}
c*{1} \\
c_{2} \\
. \\
. \\
c_{n}
\end{pmatrix}
\end{aligned}
\]</span> 形象的理解就是，A 语言有一段话，你把 A 语言用 B
语言描述出来，那么输出的就是 B 语言下对这段话的描述 所以关键在于求解
<span class="math inline">\(A_{B}\)</span>，如何用 B 语言去描述 A
语言，用 B 语言下每一个基本的单词去描述 A 语言
中间我们将普通话（标准基作为过渡），因为我们写出 B 基和 A
基的时候就是用标准基去书写（这已经是一个翻译的过程了） <img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e1233edcbaf.png" alt="Screenshot 2025-03-24 171707.png"></p>
<p>所以我们可以得到 <span class="math display">\[
A_{B}=B^{-1}A
\]</span></p>
<h2 id="内积">内积</h2>
<p>内积通俗来讲就是点乘，<span class="math inline">\(\vec{u}·\vec{v}\)</span>，我们在初中阶段就已经知道点乘表示的是一个向量在另一个向量上的投影长度乘上另一个向量的原长度。但是你们有没有思考过为什么？点乘和矩阵相乘，线性变换有什么关联吗？
<span class="math display">\[
\begin{pmatrix}
u_{1} \\
u_{2} \\
\end{pmatrix}·\begin{pmatrix}
v_{1} \\
v_{2} \\
\end{pmatrix}=u_{1}v_{1}+u_{2}v_{2}+u_{3}v_{3}=\begin{pmatrix}
u_{1}&amp;u_{2}
\end{pmatrix}\begin{pmatrix}
v_{1} \\
v_{2} \\
\end{pmatrix}
\]</span>
其中我们在矩阵相乘时习惯性用转置的符号去书写（其实没什么区别，就是整齐好看罢了），即：
<span class="math display">\[
\begin{pmatrix}
u_{1} \\
u_{2} \\
\end{pmatrix}^{T}\begin{pmatrix}
v_{1} \\
v_{2} \\
\end{pmatrix}
\]</span>
还记得我们在<strong>初步认识矩阵</strong>章节中提到的<strong>将矩阵看成线性变换</strong>吗？
同理，在这里我们把 <span class="math inline">\(\begin{pmatrix}u_{1}&amp;u_{2}\end{pmatrix}\)</span>
看成二维空间向一维空间的坍缩变换，例如： <img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cbdcb8e3.png" alt="内积.png">
<strong>这个变换是线性的吗，如何看这个坍缩的过程？</strong>
我们在空间中定义一个全新的倾斜的数轴，空间中的向量或者点投射到这个数轴上的变换就是一个坍缩的过程。由于空间中等距的点投射到这个数轴上仍然等距，原点不动，所以这样的坍缩变换仍然是线性变换
<img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cbda0f58.png" alt="内积变换.png">
所以内积就可以看成一个向量往一个倾斜数轴上投射的坍缩变换的过程，我们通过
<span class="math inline">\(\begin{pmatrix}u_{1}&amp;u_{2}\end{pmatrix}\)</span>
这个矩阵找出投射数轴，然后将 <span class="math inline">\(\begin{pmatrix}v_{1}\\v_{2}\end{pmatrix}\)</span>
投射到这个数轴上，投射得到的一维向量就是我们想要的结果（因为是一维向量所以就可以看成一个标量数字了）</p>
<p><strong>具体如何理解投射的过程呢？</strong> 我们定义一个单位向量
<span class="math inline">\(\vec{u}=(u_{x},u_{y})\)</span>，两个标准基投影到
<span class="math inline">\(\vec{u}\)</span> 的长度恰好等于 <span class="math inline">\(u_{x}\)</span> 和 <span class="math inline">\(u_{y}\)</span>（画个图即可理解）。然后对于任意向量我们都可以正交分解为水平和竖直方向向量，两个方向投影到这个数轴的长度就是在这个方向向量的长度乘上
<span class="math inline">\(u_{x}或者u_{y}\)</span>，这两个方向投影的长度加起来就是这个任意向量投影到这个数轴的长度（画图全等三角形证明）
所以对于任意向量与这个单位向量的内积就等于： <span class="math display">\[
\vec{v}·\vec{u}=v_{x}u_{x}+v_{y}u_{y}
\]</span>
那么对于任意两两向量的内积，就可以<strong>先把一个向量变成单位向量</strong>，进行内积之后乘上模长即可
我们得到公式： <span class="math display">\[
\vec{v}·\vec{u}=| |\vec{v}| |*|
|\vec{u}| |*&lt;\vec{v},\vec{u}&gt;
\]</span></p>
<p><strong>那为什么内积的先后顺序不影响内积结果呢?</strong>
矩阵的线性变换和乘积先后有关系，但是为什么内积的结果就和乘积先后无关呢？
我们可以直接从上面推导出来的式子得出，不管把哪个先处理成单位向量，乘积大小都和顺序无关（无非就是把刚刚的
<span class="math inline">\(\vec{u}\)</span> 换成 <span class="math inline">\(\vec{v}\)</span> 罢了） ### 广义内积 (投影变换)
刚刚我们理解了两个列向量之间的内积，接下来我们推广到矩阵与矩阵之间的内积
<span class="math display">\[
A·B=A^TB
\]</span> 我们一样可以通过投射的思想来理解这件事情，举个具体的例子 <span class="math display">\[
\begin{pmatrix}
1&amp;2 \\
3&amp;4
\end{pmatrix}·\begin{pmatrix}
3&amp;4 \\
5&amp;6
\end{pmatrix}=\begin{pmatrix}
1&amp;3 \\
2&amp;4
\end{pmatrix}\begin{pmatrix}
3&amp;4 \\
5&amp;6
\end{pmatrix}
\]</span> 这里相当于先把 <span class="math inline">\(\begin{pmatrix}1&amp;3\\2&amp;4\end{pmatrix}\)</span>
作单位化处理，找出 <span class="math inline">\(\begin{pmatrix}1&amp;3\end{pmatrix}\)</span> 和
<span class="math inline">\(\begin{pmatrix}2&amp;4\end{pmatrix}\)</span>
对应的投射数轴，然后计算 <span class="math inline">\(\begin{pmatrix}3\\5\end{pmatrix}\)</span> 和 <span class="math inline">\(\begin{pmatrix}4\\6\end{pmatrix}\)</span>
分别投射到这两个数轴的长度，再乘上 <span class="math inline">\(\begin{pmatrix}1&amp;3\end{pmatrix}\)</span> 和
<span class="math inline">\(\begin{pmatrix}2&amp;4\end{pmatrix}\)</span>
对应的模长。得到的结果矩阵就包含了数轴投射的信息 <span class="math display">\[
\begin{aligned}  
\begin{pmatrix}
1*3+3*5&amp;1*4+3*6 \\
2*3+4*5&amp;2*4+4*6
\end{pmatrix}
\\=\begin{pmatrix}
18&amp;22 \\
26&amp;32
\end{pmatrix}
\\=\begin{pmatrix}
\sqrt{ 10 }*\frac{18}{\sqrt{ 10 }}&amp;\sqrt{ 10 }*\frac{22}{\sqrt{ 10
}} \\
\sqrt{ 20 }*\frac{26}{\sqrt{ 20 }}&amp;\sqrt{ 20 }*\frac{32}{\sqrt{ 20
}}
\end{pmatrix}
\\=\begin{pmatrix}
\sqrt{ 10 }&amp;0 \\
0&amp;\sqrt{ 20 }
\end{pmatrix}\begin{pmatrix}
\frac18{\sqrt{ 10 }}&amp;\frac{22}{\sqrt{ 10 }} \\
\frac{26}{\sqrt{ 20 }}&amp; \frac{32}{\sqrt{ 20 }}
\end{pmatrix}
\end{aligned}
\]</span>
从这个角度也可以体会到矩阵相乘的另外一层意义，<strong>从向量方程入手</strong>一章我们讲了从拉伸转动坐标系的角度理解矩阵相乘，而<strong>内积</strong>这一小节告诉我们可以从投射的角度理解<strong>矩阵相乘和矩阵转置</strong>：先做投射，把投射数轴形成新的坐标系，表示出在新投影坐标系中原来向量的坐标（<strong>注意这里的坐标大小是投影大小而不是平行过去</strong>），然后把新坐标系的单位长度拉长为被投射向量模长，我们姑且把这个变换叫做<strong>投射变换</strong>吧</p>
<h1 id="特征向量特征值与对角化">特征向量、特征值与对角化</h1>
<p>通常我们通过这样一个式子初步理解特征向量（规定 <span class="math inline">\(\vec{x}\neq 0\)</span>）和特征值 <span class="math display">\[
A\vec{x}=\lambda\vec{x}
\]</span> 对于一个矩阵 <span class="math inline">\(A\)</span>
我们能找到一组或多组{<span class="math inline">\(\lambda_{i}，\vec{x}_{i}\)</span>}满足这个等式
从几何的角度来讲就是，通过 A 线性变换后 <span class="math inline">\(\vec{x}\)</span>
仍然在原来所在的直线上，相当于只进行了伸长压缩
如何去计算呢？显然，我们在右侧乘上一个单位阵 <span class="math inline">\(I\)</span>，进行如下变换： <span class="math display">\[
(A-\lambda I)\vec{x}=0
\]</span></p>
<p>如果 <span class="math inline">\((A-\lambda I)\)</span>
满秩的话，意味着当且仅当 <span class="math inline">\(\vec{x}=\vec{0}\)</span>
时，才满足此式。从几何角度很容易理解，满秩意味着对 <span class="math inline">\(\vec{x}\)</span>
做的线性变换没有降维，无论你怎么伸长转动压缩你都不会得到 <span class="math inline">\(\vec{0}\)</span>，除非 <span class="math inline">\(\vec{x}\)</span> 本身是一个零向量。所以只有 <span class="math inline">\((A-\lambda I)\)</span>
实现了降维坍缩变换的时候，才能够把 <span class="math inline">\(\vec{x}\)</span> 压缩成 <span class="math inline">\(\vec{0}\)</span>（图中在方格对角线上的向量会随着空间的压缩变成
<span class="math inline">\(\vec{0}\)</span>） <img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cc50c6be.png" alt="特征向量.png"> 所以我们计算特征值的时候就相当于求解 <span class="math display">\[
\begin{vmatrix}
A-\lambda I
\end{vmatrix}=0
\]</span> 知道 <span class="math inline">\(\lambda\)</span>
后我们反过来代入最开始的式子就可以得到特征向量了，注意特征向量的形式，唯一的
<span class="math inline">\(\lambda\)</span> 不一定对应唯一的 <span class="math inline">\(\vec{x}\)</span>，举个最简单的例子：将空间伸长为原来两倍的线性变换
<span class="math inline">\(\begin{pmatrix}2&amp;0\\0&amp;2\end{pmatrix}\)</span>
下，空间中每个向量经过变换后都仍然在它原本的线上</p>
<p><strong>为了更方便地去表示变换后仍然共线的向量，所以我们提取最大公因数后把公共向量表达特征向量</strong>
（从另一个角度来说就是对同一个 <span class="math inline">\(\lambda\)</span>
，把所有特征向量张成的空间的<strong>基向量</strong>作为最终的特征向量结果）</p>
<p>对于不同的 <span class="math inline">\(\lambda\)</span>
的得到的特征向量一定是线性独立的，这点很容易证明： <span class="math display">\[
\begin{aligned}  
A\vec{x_{1}}=\lambda_{1}\vec{x_{1}}\\
A\vec{x_{2}}=\lambda_{2}\vec{x_{2}}\\
iff c_{1},c_{2}=0,let\\
c_{1}\vec{x_{1}}+c_{2}\vec{x_{2}}=0\\
proof:\\
A(c_{1}\vec{x_{1}}+c_{2}\vec{x_{2}})=\lambda_{1}c_{1}\vec{x_{1}}+\lambda_{2}c_{2}\vec{x_{2}}=0\\
\lambda_{1}c_{1}\vec{x_{1}+\lambda_{1}c_{2}\vec{x_{2}}}=0\\
up-down=(\lambda_{2}-\lambda_{1})c_{2}\vec{x_{2}}=0\\
Because\\\lambda_{2}\neq \lambda_{1},\vec{x_{2}}\vec{\neq}0\\
So\\c_{2}=0\\
\end{aligned}
\]</span> <span class="math inline">\(c_{1}\)</span>
的证明也同理可得，所以我们可以得出不同的 <span class="math inline">\(\lambda\)</span>
对应的特征向量互相线性独立，而同一个 <span class="math inline">\(\lambda\)</span>
下的多个特征向量也互相线性独立，所以所有得到的特征向量都满足线性独立
综合所有特征向量所张成的空间我们叫做<strong>特征空间（Eigen-space）</strong>
### 特征向量、特征值与对角化的关系 假如 <span class="math inline">\(A\)</span> 矩阵很特殊，是一个对角矩阵 <span class="math display">\[
\begin{pmatrix}
a&amp;0&amp;0 \\
0&amp;b&amp;0 \\
0&amp;0&amp;c
\end{pmatrix}
\]</span> 它表示的意思就是每个维度伸长 a/b/c 倍，这意味着特征值就是 a,
b, c（这可以从行列式=0
的角度理论性地理解；也可以从几何上来看，刚好在坐标轴上的向量伸长对应的倍数）
在对角化矩阵乘法中，我们可以尝到简便计算的甜头： <span class="math display">\[
\begin{aligned}  
\begin{pmatrix}
a&amp;0&amp;0 \\
0&amp;b&amp;0 \\
0&amp;0&amp;c
\end{pmatrix}^{n}\begin{pmatrix}
x \\
y \\
z
\end{pmatrix}=\begin{pmatrix}
a^{n}x&amp;0&amp;0 \\
0&amp;b^{n}y&amp;0 \\
0&amp;0&amp;c^{n}z
\end{pmatrix}
\end{aligned}
\]</span> 但如果矩阵不是对角矩阵，而且还要做很多次乘法，这怎么办？ <span class="math display">\[
A^{n}\begin{pmatrix}
e \\
f \\
g
\end{pmatrix}=?
\]</span> 为了更加具象化好理解，这里举特定的例子 <span class="math display">\[
A=\begin{pmatrix}
3&amp;1 \\
0&amp;2
\end{pmatrix}
\]</span> 我们得到它的特征值和特征向量为 <span class="math display">\[
\begin{aligned}  
\lambda_{1}=3,\vec{x_{1}}=\begin{pmatrix}
1 \\
0
\end{pmatrix}\\
\lambda_{2}=2,\vec{x_{2}}=\begin{pmatrix}
1 \\
-1
\end{pmatrix}
\end{aligned}
\]</span></p>
<p><strong>我们可以把矩阵对角化，然后做乘法</strong>
还记得我们上文提到过的<strong>基变换</strong>吗，这时候我们可以用特征空间中的特征向量（如果数量足够，即特征空间的维度
<span class="math inline">\(\geq\)</span> A 的维度）作为 A
的特征基去代替标准基。A
本身表示标准基的一种线性变换，我们把特征基语言翻译成标准基语言，在标准基下进行
A
线性变换，最后再把标准基翻译回特征基语言。所以左边式子的总体含义是在特征基视角下看
A 的线性变换，就相当于<strong>换个坐标系</strong>，但本质上 A
的伸拉操作并没有改变。此时 <span class="math display">\[
\begin{aligned}  
\begin{pmatrix}
1&amp;1 \\
0&amp;-1
\end{pmatrix}^{-1}\begin{pmatrix}
3&amp;1 \\
0&amp;2
\end{pmatrix}\begin{pmatrix}
1&amp;1 \\
0&amp;-1
\end{pmatrix}=\begin{pmatrix}
3&amp;0 \\
0&amp;2
\end{pmatrix}
\end{aligned}
\]</span> <img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cbdad20f.png" alt="对角化.png"> 我们通过计算发现，在特征基的角度下看 A
只对坐标轴进行了伸拉操作，实现了对角化 从定义理解，A
对特征向量只起到了延长收缩作用，也就是说如果我们的坐标系是以它们为坐标轴，那么
A 对应的线性变换终究只是在坐标轴上的线性缩小和放大 所谓的<strong>对 A
的对角化操作</strong>，就是把式子变换一下，变成： <span class="math display">\[
\begin{pmatrix}
3&amp;1 \\
0&amp;2
\end{pmatrix}=\begin{pmatrix}
1&amp;1 \\
0&amp;-1
\end{pmatrix}\begin{pmatrix}
3&amp;0 \\
0&amp;2
\end{pmatrix}\begin{pmatrix}
1&amp;1 \\
0&amp;-1
\end{pmatrix}^{-1}
\]</span> 这样就可以对 <span class="math inline">\(A^{n}\)</span>
计算做简化处理了
由此我们可以得到能否对矩阵做对角化的<strong>约束条件</strong>： <span class="math display">\[
di mA=di m(Eigen-space)
\]</span> 如果特征空间的维度低于 A
的维度，那么意味着无法用特征向量去表征 A 所在的空间
这里引入一个<strong>相似</strong>的概念：A 如果能对角化得到对角矩阵
B，那么则称 <strong>A 与 B 互为相似矩阵</strong>（这很好理解，<strong>A
表示的在标准基下的变换</strong>等效于 <strong>B
表示的在特征基下的变换</strong>，所以它俩相似） # 正交与对角</p>
<p>对于向量空间中的一组基 <span class="math inline">\(B=\{\vec{b_{1}},\vec{b_{2}},\vec{b_{3}}\dots  \vec{b_{n}}\}\)</span>
如果满足： <span class="math display">\[
\begin{aligned}  
\forall    \vec{b_{i}}，\vec{b_{j}}inB,\\
\vec{b_{i}}·\vec{b_{j}}=0\\
Then \, we \,ca l l \, B \,as \, ort hogona l \,basis
\end{aligned}
\]</span>
也就是说正交基中向量都互相垂直，显然它们互相线性独立（验证是否线性独立就一个方法：当且仅当所有
<span class="math inline">\(c_{i}=0\)</span>，满足 <span class="math inline">\(\sum_{i=1}^{n}c_{i}\vec{b_{i}}=0\)</span>）如果正交基中所有向量的模长都为一，那么就叫做<strong>标准正交基</strong></p>
<p>如果把这组基写成矩阵的形式，而且规定 <span class="math inline">\(|
|\vec{b_{i}}| |=1，B\in
R^{n*n}\)</span>，那么这就叫做正交矩阵（orthogonal
matrix）。为什么要提到正交矩阵呢？因为用正交矩阵我们可以以一种更加规范的方式去表征我们的空间（两两互相垂直，是不是相当于把坐标轴在空间中旋转呢？hh）</p>
<p>了解了空间中正交矩阵的概念，我们不难理解以下性质（用&lt; <span class="math inline">\(\vec{u},\vec{v}\)</span>
&gt;表示两个向量夹角余弦值）： <span class="math display">\[
\begin{aligned}  
B^{T}·B=B·B^T=I\\
B^T=B^{-1}\\
&lt;B\vec{x},B\vec{y}&gt;  = &lt;\vec{x},\vec{y}&gt;\\
| |B\vec{x}| |=| |\vec{x}| |
\end{aligned}
\]</span> 做线性变换 B
相当于旋转平移坐标轴，这不会改变两个向量之间的夹角和向量的模长。教科书中常常写的是
<span class="math inline">\(B^{T}\vec{x}\)</span>
的形式，这其实不难理解，因为正交矩阵的逆就是它的转置，所以上述公式中
<span class="math inline">\(B^T\)</span> 和 <span class="math inline">\(B\)</span>
互换也没关系（只是旋转平移的方向相反而已）</p>
<h2 id="正交化">正交化</h2>
<p>在大多数情况下，向量空间中我们已知的基都比较“草率”，我们需要对它们进行规范化处理，即把它们变成正交基，写成正交矩阵形式。这个正交化的过程我们叫做<strong>格拉姆-施密特正交化（Gram-Schmit
Process）</strong>
简单来说，这是一个做投影的过程，我们现在手头有一组无规则的基 <span class="math inline">\(A=\{\vec{a_{1}},\vec{a_{2}},\vec{a_{3}}\dots  \vec{a_{n}}\}\)</span>，我们现在需要把它转化成正交基
<span class="math inline">\(B=\{\vec{b_{1}},\vec{b_{2}},\vec{b_{3}}\dots  \vec{b_{n}}\}\)</span>
<img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cc37e2fd.jpg" alt="正交化.jpg"> 我们先令 <span class="math inline">\(\vec{b_{1}}=\vec{a_{1}}\)</span>，<span class="math inline">\(\vec{b_{2}}=\vec{a_{2}}-&lt;\vec{a_{2}},\vec{\frac{b_{1}}{|
|\vec{b_{1}}| |}}&gt;*\vec{\frac{b_{1}}{| |\vec{b_{1}}| |}}\)</span>
以此类推，第 i 个向量 <span class="math inline">\(\vec{b_{i}}\)</span>
等于<strong>第 i 个向量 <span class="math inline">\(\vec{a_{i}}\)</span>
减去 <span class="math inline">\(\vec{a_{i}}\)</span> 在前 i-1
个向量张成空间中的投影向量</strong>，这样不断循环最终可以得到一组正交基
这可以用一个循环程序的思想来叙述： <span class="math display">\[
\begin{aligned}
\vec{b_{1}}=\vec{a_{1}}\\
for (k=2; k&lt;n+1;k++)\\
\left\{ \\
\vec{b_{k}}=\vec{a_{k}}-\sum_{i=1}^{k-1}&lt;\vec{b_{i},a_{k}}&gt;\vec{b_{i}}\\,
\vec{b_{k}}=\frac{\vec{b_{k}}}{| |\vec{b_{k}}| |}
  \right\}
\end{aligned}
\]</span>
（这可能看上去很复杂，其实就是对上面加粗的话用数学语言来表示，注意这里均对
<span class="math inline">\(\vec{b_{i}}\)</span>
做单位化处理。我们很容易理解 <span class="math inline">\(\vec{a_{k}}\)</span> 在前 k-1
个向量中各做投影向量，这些投影向量的矢量和就是 <span class="math inline">\(\vec{a_{k}}\)</span> 在前 k-1
个向量中组成空间中的投影向量）</p>
<p>对式子进行移项，我们可以得到 <span class="math display">\[
\vec{a_{k}}=\vec{b_{k}}+\sum_{i=1}^{k-1}&lt;\vec{\frac{b_{i}}{|
|\vec{b_{i}}| |},a_{k}}&gt;\left( \frac{\vec{b_{i}}}{| |\vec{b_{i}}| |}
\right)
\]</span> 用矩阵来表示： <img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cbe01a45.jpg" alt="QR分解.jpg"> 这个过程叫做 <strong>QR 分解</strong> 通常求 QR
分解的思路是先把所有的正交基求出来，再写出分解矩阵 ## 正交对角化
前文我们提到对角化，就是以下的一个过程： <span class="math display">\[
A=PDP^{-1}
\]</span> 如果此时的 <span class="math inline">\(P^T=P^{-1}\)</span>，那么我们可以把对角化称之为正交对角化（回顾上文知识点，A
与 D 是相似的）。在同济版的现代教材中我们称之为 <span class="math inline">\(A\)</span> 与 <span class="math inline">\(D\)</span>
合同，这种变换叫<strong>合同变换</strong>（其实这个名字并不是很好理解，不如记成正交对角化）：
<span class="math display">\[
A=PDP^T
\]</span> 从本质上来讲，就是 A 的特征向量组成的基刚好是一组正交基 <span class="math display">\[
P^{-1}AP=D
\]</span></p>
<p>此时我们对 <span class="math inline">\(A\)</span> 做转置处理： <span class="math display">\[
\begin{aligned}  
P^{-1}A=P^TA=DP^T\\
(P^TA)^T=(DP^T)^T\\
A^TP=PD^T=PD\\
A^T=PDP^{-1}=PDP^T=A
\end{aligned}
\]</span> 所以我们得到 <strong>A 的转置矩阵还是
A</strong>，我们称这种矩阵为<strong>对称矩阵</strong></p>
<p>那反过来看，如果 <span class="math inline">\(A^T=A\)</span>，我们是否可以找到对应的 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(D\)</span> 呢？
显然，这个问题的<strong>关键所在就是 <span class="math inline">\(A^T=A\)</span>
是否意味着特征向量能表征的维度大于等于A
的维度</strong>，如果大于等于就说明可以对角化，再根据 <span class="math inline">\(A^T=A\)</span> 就可以推出这是正交对角化 <span class="math display">\[
A  \vec{x}=\lambda  \vec{x}
\]</span> 首先对称矩阵意味着它是一个方阵，<span class="math inline">\(A\in R^{n*n}\)</span> 齐次，<span class="math inline">\(A^T=A\)</span>
意味着投射变换和纯坐标系变换是等效的
这里我们举一个<strong>特殊的例子</strong>来帮助理解（坐标系对角压缩，就是两个基向量对称靠近的过程）
<strong>我们可以找到两个特征向量</strong>（至于怎么找的可以拿一个具体类似的矩阵去验证一下），这两个特征向量在纯坐标系转换视角下的坐标和在投射变换视角下的坐标大小一致，标同样颜色的两两互相相等。更推广地来说，如果把基向量拉长，整体空间都是线性拉长，所以两种转换视角出来一样等效。我们在两种转换等效的情况下可以找到充足的特征向量去表征
A 的维度 <img src="/img/loading.gif" data-original="https://img.picui.cn/free/2025/03/24/67e11cc2e4dad.jpg" alt="投射等效.jpg">
有的时候对于一些定理我们不一定要追求严格完整的理论证明（我们也不是抖 S
数学家对吧）。这一段证明其实需要通过数学归纳法进行一长串的推导，比较绕，所以我们可以通过一个特例画图分析来感性地理解这件事情
## 二次型 (Quadratic Forms)</p>
<p>我们在研究数学问题时常常碰到非线性规划问题，求解一个多元二次函数的最值，比如：
<span class="math display">\[
\begin{aligned}  
\vec{x}=\begin{pmatrix}
x_{1} \\
x_{2} \\
x_{3} \\
. \\
. \\
x_{n}
\end{pmatrix}\\
f(\vec{x})=\sum_{i=1,j=1}^{n}c_{ij}x_{i}x_{j}
\end{aligned}
\]</span> 通常我们求解的是 <span class="math inline">\(f(\vec{x})\)</span>
的最大值或者最小值，这个计算量通常很大，我们需要扔给计算机操作。而计算机能够进行矩阵运算，所以我们如果能把这个函数化成矩阵形式，那么我们就可以扔给计算机操作了。观察这个式子，我们可以写成如下矩阵形式：
<span class="math display">\[
\begin{pmatrix}
x_{1}&amp;x_{2}&amp;\dots&amp;x_{n}
\end{pmatrix}\begin{pmatrix}
c_{11}&amp;c_{21}&amp;\dots&amp;c_{n_{1}} \\
c_{12} \\
. \\
. \\
c_{1n}&amp;c_{2n}&amp;\dots&amp;c_{nn}
\end{pmatrix}\begin{pmatrix}
x_{1} \\
x_{2} \\
. \\
. \\
x_{n}
\end{pmatrix}
\]</span> 由于 <span class="math inline">\(c_{ij}x_{i}x_{j}\)</span> 和
<span class="math inline">\(c_{ji}x_{j}x_{i}\)</span>
可以合并，所以我们再对上面的矩阵进行转换 <span class="math display">\[
\begin{pmatrix}
x_{1}&amp;x_{2}&amp;\dots&amp;x_{n}
\end{pmatrix}\begin{pmatrix}
c_{11}&amp;\frac{c_{12}}{2}&amp;\dots&amp;\frac{c_{1n}}{2} \\
\frac{c_{12}}{2} \\
. \\
. \\
\frac{c_{1n}}{2}&amp;\frac{c_{2n}}{2}&amp;\dots&amp;c_{nn}
\end{pmatrix}\begin{pmatrix}
x_{1} \\
x_{2} \\
. \\
. \\
x_{n}
\end{pmatrix}
\]</span>
这时候我们注意到中间那个矩阵是一个对称矩阵，而左右两边的矩阵互为转置关系（这其实有点像正交对角化的样子，但不是哈）
因此我们可以把函数写成： <span class="math display">\[
f(\vec{x})=\vec{x}^TD \vec{x}
\]</span> 我们定义<strong>对称矩阵 <span class="math inline">\(D\)</span> 的秩为二次函数的秩</strong>。 由于
<span class="math inline">\(D\)</span>
是一个对称矩阵，所以根据正交对角化的知识，我们可以对 <span class="math inline">\(D\)</span> 进行正交对角化（P 是正交矩阵，D
是对角矩阵）<strong>根据特征值和对角化关系，G 中的每一个非零元素就是矩阵
D 的特征值，P
就是特征向量组成的矩阵</strong>（要是不理解就看回特征向量那一章） <span class="math display">\[
D=PGP^T
\]</span> 带入到函数中，我们可以得到： <span class="math display">\[
\begin{aligned}  
f(\vec{x})=\vec{x}^TPGP^T \vec{x}=(P^T \vec{x})^TG(P^T
\vec{x})=\vec{y}^TG \vec{y}
\\=\begin{pmatrix}
y_{1}&amp;y_{2}&amp;\dots&amp;y_{n}\end{pmatrix}G\begin{pmatrix}
y_{1} \\
y_{2} \\
. \\
. \\
y_{n}
\end{pmatrix}=\sum_{i=1}^{n}\lambda_{i}y_{i}^2
\end{aligned}
\]</span></p>
<ul>
<li><span class="math inline">\(\lambda_{i}\)</span> 是 G 中的元素，由于
P 是正交矩阵，所以 <span class="math inline">\(| |\vec{y}| |=| |\vec{x}|
|\)</span>，这个过程叫做标准化二次型</li>
<li>如果 <span class="math inline">\(\lambda_{i}\)</span> 为 1
或者-1，那么这个就叫做规范化二次型，你只需要对 <span class="math inline">\(y_{i}\)</span> 进行处理就可以改变前面的系数了</li>
<li>如果 <span class="math inline">\(\forall \lambda_{i}&gt;
0\)</span>，那么原来的 A 叫做<strong>正定阵</strong>，若 <span class="math inline">\(\forall \lambda_{i}&lt; 0\)</span>，那么原来的
A叫做<strong>负定阵</strong>，其余情况下叫做不定矩阵，这个通常用于求最小值或者最大值（在
<span class="math inline">\(y_{i}=0\)</span>
时候才可能取最值，线性规划经常用到）</li>
<li>在实际做题中，我们通常使用配方法（配成 <span class="math inline">\((x_{i}+x_{j})^2\)</span>
诸如此类）或者待定系数平方差（当初始式子只有不同 x 的乘积）直接求出
<span class="math inline">\(\lambda_{i}\)</span></li>
</ul>
<h1 id="结语">结语</h1>
<p>如果你认真看到了这里，那么恭喜你，你对线性代数的理解更加深入了。这些几何意义上的理解看似对做题正确率没有什么太大的意义，但对将来我们学习概率论，泛函分析等打下坚实的基础。密密麻麻的证明公式不一定记得住，但简约的几何印象一定会深深印刻在我们的脑海里。
-----24 级大一小登 <span class="math inline">\(WJ_{silence-br
eaker}\)</span></p>
<script>
MathJax = {
  tex: {
    inlineMath: [['$', '$'], ['\\(', '\\)']]
  }
};
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://silence-breaker.github.io">silence-breaker</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://silence-breaker.github.io/2025/03/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/">https://silence-breaker.github.io/2025/03/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://silence-breaker.github.io" target="_blank">靖玄电</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://img.sosoos.com/i/2025/01/22/207159.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/loading.gif" data-original="https://img.sosoos.com/i/2025/01/22/207159.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">silence-breaker</div><div class="author-info-description">学无止境</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/silence-breaker"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/silence-breaker" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E7%9F%A9%E9%98%B5"><span class="toc-number">1.</span> <span class="toc-text">初步认识矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84%E5%85%A5%E6%89%8B"><span class="toc-number">1.1.</span> <span class="toc-text">从线性方程组入手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%90%91%E9%87%8F%E6%96%B9%E7%A8%8B%E5%85%A5%E6%89%8B"><span class="toc-number">1.2.</span> <span class="toc-text">从向量方程入手</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">如何理解一个矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E7%AD%89%E8%A1%8C%E5%8F%98%E6%8D%A2"><span class="toc-number">1.2.2.</span> <span class="toc-text">初等行变换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">行列式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E7%A9%BA%E9%97%B4null-space"><span class="toc-number">1.3.</span> <span class="toc-text">零空间（Null space）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%A7%AF"><span class="toc-number">1.4.</span> <span class="toc-text">内积</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E5%AF%B9%E8%A7%92%E5%8C%96"><span class="toc-number">2.</span> <span class="toc-text">特征向量、特征值与对角化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">正交化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">3.</span> <span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/03/24/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/" title="线性代数应该这么学">线性代数应该这么学</a><time datetime="2025-03-24T03:34:57.000Z" title="发表于 2025-03-24 11:34:57">2025-03-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/21/USART%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/" title="USART串口通信学习">USART串口通信学习</a><time datetime="2025-02-21T09:16:03.000Z" title="发表于 2025-02-21 17:16:03">2025-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/HAL%E5%BA%93%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/" title="HAL库函数汇总">HAL库函数汇总</a><time datetime="2025-02-17T09:08:26.000Z" title="发表于 2025-02-17 17:08:26">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/17/%E5%9F%BA%E4%BA%8EHAL%E5%BA%93%E7%9A%84ADC%E6%A8%A1%E6%95%B0%E8%BD%AC%E6%8D%A2%E5%99%A8+DMA%E5%AD%A6%E4%B9%A0/" title="基于HAL库的ADC模数转换器+DMA学习">基于HAL库的ADC模数转换器+DMA学习</a><time datetime="2025-02-17T07:39:57.000Z" title="发表于 2025-02-17 15:39:57">2025-02-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/02/15/%E5%9F%BA%E4%BA%8EHAL%E5%BA%93%E7%9A%84%E7%BC%96%E7%A0%81%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/" title="基于HAL库的编码器模式学习">基于HAL库的编码器模式学习</a><time datetime="2025-02-15T15:28:17.000Z" title="发表于 2025-02-15 23:28:17">2025-02-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By silence-breaker</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      pjax.loadUrl('/404.html')
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div>
        <style>
            [bg-lazy] {
                background-image: none !important;
                background-color: #eee !important;
            }
        </style>
        <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})});</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>